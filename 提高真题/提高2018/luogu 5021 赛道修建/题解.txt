参考：https://www.luogu.com.cn/blog/CodyTheWolf/solution-p5021
看题目描述肯定一下就能想到二分答案。
也很容易想到二分m条赛道中最小的那一个，也可以理解为画一条分界线mid，看看比mid大或者等于的赛道能不能有m个。

对于一个点，从它子树发源的赛道，最多只能有一条穿过它并向上贡献，因为父亲边是唯一的，多一条赛道肯定会在边上重复。

我们考虑一下贪心：
如果现在树只有两层（一个树根和一堆儿子），我们的肯定希望这个子树多出现赛道。我们把边全部排序，然后从最小的边开始，用分界线mid减去这个边的边权，设为x。显然，给这个边找一条比x大一点或者等于的边即可，因为比x长的边虽然也能和当前匹配，但是后面我们其他的匹配或者是要向上贡献的机会可能就少了，因此可能会不优。

我们现在已经完成子树内的最大匹配了，我们找出链中没有用过的最长链（可以是空链，也就是0），作为向上的贡献（具体做法也就是记一个点权，点权也就是那个最长链的长度）。

这个时候，我们最下面那一层已经没有意义了，因为我们已经匹配好了，并且找出了最长链，其他已经匹配的赛道或者比最长链小的链已经没有用处了。那么我们可以看作把这一层全部消掉，显然是没有问题的（这时候的最长链已经被当作点权了）。

这样我们可以用DFS的方式，从下往上把树不停的“消层”，直至没有。

需要注意的是，最下层解决完毕以后，后面的层的链是边权+点权，这才是我们的链。当然也可以看作最下层的点权是0。

在全局的设个变量res记录还需要找到几条赛道。先让res等于m，每次在子树匹配成功，就res--，DFS全部结束的时候只要判断res是不是小于等于0就知道是否成功了。
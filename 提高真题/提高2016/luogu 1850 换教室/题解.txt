那么很显然啊，我们首先要预处理出每两个点之间的最短路来，方便状态的转移
注意可能floyd初始化,f[I][I]=0,不然求出来自己到自己会需要时间，实际上完全有可能两个时间段都在一个点。
然后就是DP方程了:

我们定义dp[i][j][0/1]来表示当前为第i个阶段，连同这一次已经用了j次换教室的机会，当前这次换(1)不换(0)的最小期望路程总和。
那么转移就可以如此转移：

这次不换： dp[i][j][0]=dp[i][j][0]= min(min(上次不换的dp+这两次之间的路程，上次概率换了之后的dp++p[i−1]×上次换了的教室与这次不换的教室之间的距离+(1-p[i - 1])×上次不换的教室与这次不换的教室之间的距离)

dp[i][j][0]=min(dp[i-1][j][0]+f[c[i-1]][c[i]],dp[i-1][j][1]+f[d[i-1]][c[i]]*p[i-1]+f[c[i-1]][c[i]]*(1-p[i-1]));
        
dp[i][j][1]=min(dp[i-1][j-1][0]+f[c[i-1]][d[i]]*p[i]+f[c[i-1]][c[i]]*(1-p[i]),dp[i-1][j-1][1]+f[c[i-1]][c[i]]*(1-p[i-1])*(1-p[i])+f[c[i-1]][d[i]]*(1-p[i-1])*p[i]+f[d[i-1]][c[i]]*(1-p[i])*p[i-1]+f[d[i-1]][d[i]]*p[i-1]*p[i]);
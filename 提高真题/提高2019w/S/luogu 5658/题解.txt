对于链的情况，如果当前出现的为)，则匹配之前的位置(，刚好匹配成一对，设匹配的上一个(的位置为j，f表示以当前位置为结尾总共可以形成的匹配数量，则答案为f[i]=f[j-1]+1。
如果为(括号，则不用处理。如何来处理出每个位置所对应的左括号，用经典的栈操作即可（进栈出栈处理匹配关系）。
如果括号序列为树上，则一样，我们要维护每条链的状态。
在树上多了一个回溯过程，如果当前的为)，则返回的时候查看一下是否匹配掉了一个（，有的话，则加入一个（。